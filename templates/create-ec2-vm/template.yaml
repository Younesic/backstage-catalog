apiVersion: scaffolder.backstage.io/v1beta3
kind: Template
metadata:
  name: virtualmachine
  title: VirtualMachine
  description: >-
    Crée un claim Crossplane VirtualMachine et injecte automatiquement
    l'annotation terasky.backstage.io/owner afin que le plugin Kubernetes
    Ingestor renseigne correctement le propriétaire du composant Backstage.
spec:
  type: service

  # ------------------------------
  # 1. FORM PARAMETERS
  # ------------------------------
  parameters:
    - title: Resource Metadata
      required: [xrName, xrNamespace, owner]
      properties:
        xrName:
          title: Name
          description: Unique name for the VirtualMachine claim (DNS-1123)
          type: string
          pattern: '^[a-z0-9]([-a-z0-9]*[a-z0-9])?$'
          maxLength: 63
        xrNamespace:
          title: Namespace
          description: Target namespace (default if omitted)
          type: string
          pattern: '^[a-z0-9]([-a-z0-9]*[a-z0-9])?$'
          maxLength: 63
          default: default
        owner:
          title: Owner (Backstage group)
          type: string
          ui:field: OwnerPicker
          ui:options:
            catalogFilter:
              kind: [Group]

    - title: Resource Spec
      required: [parameters]
      properties:
        parameters:
          title: Parameters
          type: object
          required: [size]
          properties:
            size:
              title: Instance size
              enum: [nano, micro, small, medium, large]
              type: string

    - title: Crossplane Settings
      properties:
        compositionSelectionStrategy:
          title: Composition Selection Strategy
          type: string
          enum: [runtime, direct-reference, label-selector]
          default: runtime
        compositionRef:
          title: Composition Reference (strategy = direct-reference)
          type: object
          properties:
            name:
              title: Composition name
              type: string
              enum: [vm-aws-micro, vm-aws-nano]
        compositionSelector:
          title: Composition Selector (strategy = label-selector)
          type: object
          properties:
            matchLabels:
              title: Match Labels
              type: object
              additionalProperties:
                type: string

    - title: Creation Settings
      properties:
        pushToGit:
          title: Push manifest to GitOps repository
          type: boolean
          default: true
        repoUrl:
          title: Repository URL (github.com?owner=<ORG>&repo=<REPO>)
          type: string
          ui:field: RepoUrlPicker
          ui:options:
            allowedHosts: [github.com, gitlab.com]
        targetBranch:
          title: Target branch
          type: string
          default: main
        manifestLayout:
          title: Manifest layout
          type: string
          enum: [cluster-scoped, namespace-scoped, custom]
          default: cluster-scoped
        clusters:
          title: Target clusters (if cluster-scoped)
          type: array
          items:
            type: string
            enum: [microk8s-cluster]
          ui:widget: checkboxes
        basePath:
          title: Base path (if custom layout)
          type: string

  # ------------------------------
  # 2. WORKFLOW STEPS
  # ------------------------------
  steps:
    # 2.1 Generate the basic claim manifest
    - id: generate
      name: Generate claim YAML
      action: terasky:claim-template
      input:
        claimKind: VirtualMachine
        claimGroup: platform.example.org
        claimVersion: v1alpha1
        fileName: vm-claim.yaml
        metadata:
          name: ${{ parameters.xrName }}
          namespace: ${{ parameters.xrNamespace }}
        spec:
          parameters:
            size: ${{ parameters.parameters.size }}

    # 2.2 Inject owner annotation so Ingestor sets spec.owner correctly
    - id: inject-owner
      name: Inject owner annotation
      action: yaml:set
      input:
        targetFile: ${{ steps.generate.output.targetPath }}
        path: metadata.annotations.terasky.backstage.io/owner
        value: ${{ parameters.owner }}

    # 2.3 Optional: add compositionRef when strategy is direct-reference
    - id: add-compositionRef
      if: ${{ parameters.compositionSelectionStrategy == 'direct-reference' }}
      name: Add compositionRef
      action: yaml:set
      input:
        targetFile: ${{ steps.generate.output.targetPath }}
        path: spec.compositionRef.name
        value: ${{ parameters.compositionRef.name }}

    # 2.4 Optional: add compositionSelector when strategy is label-selector
    - id: add-compositionSelector
      if: ${{ parameters.compositionSelectionStrategy == 'label-selector' }}
      name: Add compositionSelector
      action: yaml:set
      input:
        targetFile: ${{ steps.generate.output.targetPath }}
        path: spec.compositionSelector.matchLabels
        value: ${{ parameters.compositionSelector.matchLabels }}

    # 2.5 Publish phase - push to Git or provide download link
    - id: publish-git
      if: ${{ parameters.pushToGit }}
      name: Publish manifest to Git
      action: publish:github
      input:
        repoUrl: ${{ parameters.repoUrl }}
        branchName: vm-${{ parameters.xrName }}
        targetPath: ${{ steps.generate.output.targetPath }}
        commitMessage: "feat: add VirtualMachine ${{ parameters.xrName }}"
        targetBranch: ${{ parameters.targetBranch }}

    - id: publish-file
      if: ${{ !parameters.pushToGit }}
      name: Provide manifest for download
      action: publish:file
      input:
        path: ${{ steps.generate.output.targetPath }}

  # ------------------------------
  # 3. OUTPUT MESSAGE
  # ------------------------------
  output:
    text: |
      ✅ Claim manifest generated for **${{ parameters.xrName }}**.
      {% if parameters.pushToGit %}
      A pull-request has been opened in **${{ parameters.repoUrl }}** (branch `${{ parameters.targetBranch }}`).
      {% else %}
      Download the YAML above, then apply it with:
        kubectl apply -f <file.yaml>
      {% endif %}